import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { sendInteractiveWhatsAppMessage, sendWhatsAppMessage } from '@/lib/whatsapp';
import { MessagesList } from '@/app/api/utlis/constants';
import { getClientLanguageSettings, getLocalizedMessages} from '@/services/server/notifications/languageUtils';

// For serverless environments, use a connection per request
// Don't keep the connection globally as it may cause issues with concurrent requests
let prisma;

// Function to get Prisma client and handle connection properly
function getPrismaClient() {
  if (!prisma) {
    prisma = new PrismaClient();
  }
  return prisma;
}

// Store processed webhook IDs to prevent duplicate processing
// In production, use Redis or another distributed cache
const processedWebhookIds = new Set();

// Store active language selection sessions
const languageSelectionSessions = new Map();

// Message templates for localization
const messages = {
  welcomeMessage: {
    ar: "Ù…Ø±Ø­Ø¨Ø§Ù‹! Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ØºØ¨ ÙÙŠ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ ØµÙŠØ§Ù†Ø© Ø£Ùˆ Ø´ÙƒÙˆÙ‰ Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù…ØŒ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© 'Ù…Ø³Ø§Ø¹Ø¯Ø©' Ø£Ùˆ 'ØµÙŠØ§Ù†Ø©'.",
    en: "Welcome! If you'd like to submit a maintenance request, a complaint, or contact support, please type 'help' or 'maintenance'."
  },
  maintenanceOptionsHeader: {
    ar: "Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØµÙŠØ§Ù†Ø©",
    en: "Maintenance Services"
  },
  maintenanceOptionsBody: {
    ar: "ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø®ÙŠØ§Ø± Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©:",
    en: "Please select an option to continue:"
  },
  maintenanceOptionsFooter: {
    ar: "Ø´ÙƒØ±Ø§Ù‹ Ù„ØªÙˆØ§ØµÙ„Ùƒ Ù…Ø¹Ù†Ø§",
    en: "Thank you for contacting us"
  },
  maintenanceOptionsButton: {
    ar: "Ø¹Ø±Ø¶ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª",
    en: "View Options"
  },
  maintenanceTitle: {
    ar: "ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒØŸ",
    en: "How can we help you?"
  },
  submitMaintenanceTitle: {
    ar: "ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ ØµÙŠØ§Ù†Ø©",
    en: "Submit Maintenance Request"
  },
  submitMaintenanceDesc: {
    ar: "Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø¹Ù‚Ø§Ø± Ø£Ùˆ Ø§Ù„ÙˆØ­Ø¯Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ",
    en: "Report an issue with your property or unit"
  },
  submitComplaintTitle: {
    ar: "ØªÙ‚Ø¯ÙŠÙ… Ø´ÙƒÙˆÙ‰",
    en: "Submit Complaint"
  },
  submitComplaintDesc: {
    ar: "ØªÙ‚Ø¯ÙŠÙ… Ø´ÙƒÙˆÙ‰ Ø¨Ø®ØµÙˆØµ Ø§Ù„Ø®Ø¯Ù…Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¨Ù†Ù‰",
    en: "Submit a complaint about service or property"
  },
  contactSupportTitle: {
    ar: "Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù…",
    en: "Contact Support"
  },
  contactSupportDesc: {
    ar: "Ø§Ù„ØªØ­Ø¯Ø« Ù…Ø¹ Ù…Ù…Ø«Ù„ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡",
    en: "Speak with a customer service representative"
  },
  describeMaintenanceMessage: {
    ar: "ÙŠØ±Ø¬Ù‰ ÙˆØµÙ Ù…Ø´ÙƒÙ„Ø© Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„ØªÙŠ ØªÙˆØ§Ø¬Ù‡Ù‡Ø§. Ù‚Ù… Ø¨ØªØ¶Ù…ÙŠÙ† Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø°Ø§Øª Ø§Ù„ØµÙ„Ø© Ø­ÙˆÙ„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©.",
    en: "Please describe the maintenance issue you're experiencing. Include relevant details about the problem."
  },
  describeComplaintMessage: {
    ar: "ÙŠØ±Ø¬Ù‰ ÙˆØµÙ Ø´ÙƒÙˆØ§Ùƒ Ø¨Ø§Ù„ØªÙØµÙŠÙ„. ÙƒÙ† Ù…Ø­Ø¯Ø¯Ø§Ù‹ Ù‚Ø¯Ø± Ø§Ù„Ø¥Ù…ÙƒØ§Ù† Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§ Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø´ÙƒÙ„Ø© Ø¨Ø´ÙƒÙ„ Ø£ÙØ¶Ù„.",
    en: "Please describe your complaint in detail. Be as specific as possible to help us better address the issue."
  },
  supportWillContactMessage: {
    ar: "Ø´ÙƒØ±Ø§Ù‹ Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù…. Ø³ÙŠØªØµÙ„ Ø¨Ùƒ Ù…Ù…Ø«Ù„ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ù‚Ø±ÙŠØ¨Ø§Ù‹.",
    en: "Thank you for contacting support. A customer service representative will contact you soon."
  },
  registrationRequiredMessage: {
    ar: "ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ù†Ø§ Ù‚Ø¨Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù…. Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ¹ØªÙ‚Ø¯ Ø£Ù† Ù‡Ø°Ø§ Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù…ÙƒØªØ¨Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©.",
    en: "Please register with us before contacting support. If you believe this is an error, please contact our office directly."
  },
  notFoundInSystemMessage: {
    ar: "Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù…Ù†Ø§. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù…ÙƒØªØ¨Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ.",
    en: "We couldn't find your account in our system. Please contact our office directly to submit your maintenance request."
  },
  recentRequestMessage: {
    ar: "Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ ØµÙŠØ§Ù†Ø© ÙÙŠ Ø§Ù„Ù€ 24 Ø³Ø§Ø¹Ø© Ø§Ù„Ù…Ø§Ø¶ÙŠØ©. ÙØ±ÙŠÙ‚Ù†Ø§ ÙŠØ¹Ù…Ù„ Ø¹Ù„ÙŠÙ‡. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ø£Ù…Ø±Ø§Ù‹ Ø¹Ø§Ø¬Ù„Ø§Ù‹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù…ÙƒØªØ¨Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©.",
    en: "You've already submitted a maintenance request in the past 24 hours. Our team is working on it. If this is urgent, please contact our office directly."
  },
  recentComplaintMessage: {
    ar: "Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨ØªÙ‚Ø¯ÙŠÙ… Ø´ÙƒÙˆÙ‰ ÙÙŠ Ø§Ù„Ù€ 24 Ø³Ø§Ø¹Ø© Ø§Ù„Ù…Ø§Ø¶ÙŠØ©. ÙØ±ÙŠÙ‚Ù†Ø§ ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙƒ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù…ÙƒØªØ¨Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©.",
    en: "You've already submitted a complaint in the past 24 hours. Our team is reviewing it. If you have new information, please contact our office directly."
  },
  maintenanceConfirmationTitle: {
    ar: "Ø£Ù†Øª Ø¹Ù„Ù‰ ÙˆØ´Ùƒ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ ØµÙŠØ§Ù†Ø© Ø¨Ø§Ù„ÙˆØµÙ Ø§Ù„ØªØ§Ù„ÙŠ:",
    en: "You are about to submit a maintenance request with the following description:"
  },
  complaintConfirmationTitle: {
    ar: "Ø£Ù†Øª Ø¹Ù„Ù‰ ÙˆØ´Ùƒ ØªÙ‚Ø¯ÙŠÙ… Ø´ÙƒÙˆÙ‰ Ø¨Ø§Ù„ÙˆØµÙ Ø§Ù„ØªØ§Ù„ÙŠ:",
    en: "You are about to submit a complaint with the following description:"
  },
  confirmationQuestion: {
    ar: "Ù‡Ù„ Ù‡Ø°Ø§ ØµØ­ÙŠØ­ØŸ",
    en: "Is this correct?"
  },
  confirmButton: {
    ar: "Ù†Ø¹Ù…ØŒ Ø£Ø±Ø³Ù„ Ø§Ù„Ø·Ù„Ø¨",
    en: "Confirm"
  },
  confirmComplaintButton: {
    ar: "Ù†Ø¹Ù…ØŒ Ø£Ø±Ø³Ù„ Ø§Ù„Ø´ÙƒÙˆÙ‰",
    en: "Submit"
  },
  requestSuccessMessage: {
    ar: "Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ! ØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­.\n\nØ±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: #{requestId}\nØ§Ù„ÙˆØµÙ: {description}\n\nØ³ÙŠÙ‚ÙˆÙ… ÙØ±ÙŠÙ‚Ù†Ø§ Ø¨Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡ Ù‚Ø±ÙŠØ¨Ø§Ù‹ ÙˆØ§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ.",
    en: "Thank you! Your maintenance request has been successfully submitted.\n\nRequest #: #{requestId}\nDescription: {description}\n\nOur team will review it soon and get back to you."
  },
  complaintSuccessMessage: {
    ar: "Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ! ØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø´ÙƒÙˆØ§Ùƒ Ø¨Ù†Ø¬Ø§Ø­.\n\nØ±Ù‚Ù… Ø§Ù„Ø´ÙƒÙˆÙ‰: #{complaintId}\nØ§Ù„ÙˆØµÙ: {description}\n\nØ³ÙŠÙ‚ÙˆÙ… ÙØ±ÙŠÙ‚Ù†Ø§ Ø¨Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ Ù‚Ø±ÙŠØ¨Ø§Ù‹ ÙˆØ§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ.",
    en: "Thank you! Your complaint has been successfully submitted.\n\nComplaint #: #{complaintId}\nDescription: {description}\n\nOur team will review it soon and get back to you."
  },
  errorMessage: {
    ar: "Ù†Ø£Ø³ÙØŒ ÙˆÙ„ÙƒÙ† Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ùƒ. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù…ÙƒØªØ¨Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©.",
    en: "Sorry, but an error occurred while processing your request. Please try again later or contact our office directly."
  },
  technicianAcknowledgment: {
    ar: "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ø¯Ùƒ. Ø´ÙƒØ±Ø§Ù‹.",
    en: "Your response has been received. Thank you."
  },
  technicianMaintenanceUpdated: {
    ar: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© #{requestId} Ø¥Ù„Ù‰ \"Ù‚ÙŠØ¯ Ø§Ù„ØªÙ†ÙÙŠØ°\" ÙˆØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡ Ù„Ùƒ. Ø´ÙƒØ±Ø§Ù‹.",
    en: "Maintenance request #{requestId} has been updated to \"IN PROGRESS\" and assigned to you. Thank you."
  },
  maintenanceInProgressClient: {
    ar: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ ##{requestId} Ø¥Ù„Ù‰ \"Ù‚ÙŠØ¯ Ø§Ù„ØªÙ†ÙÙŠØ°\". Ø³ÙŠÙ‚ÙˆÙ… Ø§Ù„ÙÙ†ÙŠ Ø¨Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹.",
    en: "Your maintenance request ##{requestId} has been updated to \"IN PROGRESS\". A technician will contact you shortly."
  },
  maintenanceCompletedClient: {
    ar: "ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ ##{requestId}. Ù†Ø´ÙƒØ±Ùƒ Ø¹Ù„Ù‰ ØªØ¹Ø§ÙˆÙ†Ùƒ.",
    en: "Your maintenance request ##{requestId} has been completed. Thank you for your cooperation."
  },
  maintenanceCompletedTechnician: {
    ar: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© ##{requestId} Ø¥Ù„Ù‰ \"Ù…ÙƒØªÙ…Ù„\". Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ.",
    en: "Maintenance request ##{requestId} has been marked as COMPLETED. Thank you."
  },
  complaintReviewingClient: {
    ar: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø´ÙƒÙˆÙ‰ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ ##{complaintId} Ø¥Ù„Ù‰ \"Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©\". Ø³Ù†ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹.",
    en: "Your complaint ##{complaintId} has been updated to \"REVIEWING\". We will contact you shortly."
  },
  complaintResolvedClient: {
    ar: "ØªÙ… Ø­Ù„ Ø§Ù„Ø´ÙƒÙˆÙ‰ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ ##{complaintId}. Ù†Ø´ÙƒØ±Ùƒ Ø¹Ù„Ù‰ ØªØ¹Ø§ÙˆÙ†Ùƒ.",
    en: "Your complaint ##{complaintId} has been resolved. Thank you for your cooperation."
  }
};


/**
 * WhatsApp Templates Configuration for Arabic and English support
 * These would be registered in the WhatsApp Business API
 */
const whatsappTemplates = {
  // Maintenance Request Confirmation Template
  maintenance_confirmation: {
    en: {
      name: "maintenance_confirmation_en",
      language: "en",
      components: [
        {
          type: "HEADER",
          format: "TEXT",
          text: "Maintenance Request Confirmation"
        },
        {
          type: "BODY",
          text: "Your maintenance request #{{1}} has been received.\n\nDescription: {{2}}\n\nOur team will review it shortly."
        },
        {
          type: "FOOTER",
          text: "Thank you for your patience"
        }
      ]
    },
    ar: {
      name: "maintenance_confirmation_ar",
      language: "ar",
      components: [
        {
          type: "HEADER",
          format: "TEXT",
          text: "ØªØ£ÙƒÙŠØ¯ Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø©"
        },
        {
          type: "BODY",
          text: "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø·Ù„Ø¨ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø±Ù‚Ù… {{1}}.\n\nØ§Ù„ÙˆØµÙ: {{2}}\n\nØ³ÙŠÙ‚ÙˆÙ… ÙØ±ÙŠÙ‚Ù†Ø§ Ø¨Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡ Ù‚Ø±ÙŠØ¨Ø§Ù‹."
        },
        {
          type: "FOOTER",
          text: "Ø´ÙƒØ±Ø§Ù‹ Ù„ØµØ¨Ø±Ùƒ"
        }
      ]
    }
  },
  
  // Complaint Confirmation Template
  complaint_confirmation: {
    en: {
      name: "complaint_confirmation_en",
      language: "en",
      components: [
        {
          type: "HEADER",
          format: "TEXT",
          text: "Complaint Confirmation"
        },
        {
          type: "BODY",
          text: "Your complaint #{{1}} has been received.\n\nDescription: {{2}}\n\nOur team will review it shortly."
        },
        {
          type: "FOOTER",
          text: "Thank you for your feedback"
        }
      ]
    },
    ar: {
      name: "complaint_confirmation_ar",
      language: "ar",
      components: [
        {
          type: "HEADER",
          format: "TEXT",
          text: "ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø´ÙƒÙˆÙ‰"
        },
        {
          type: "BODY",
          text: "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø´ÙƒÙˆØ§Ùƒ Ø±Ù‚Ù… {{1}}.\n\nØ§Ù„ÙˆØµÙ: {{2}}\n\nØ³ÙŠÙ‚ÙˆÙ… ÙØ±ÙŠÙ‚Ù†Ø§ Ø¨Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ Ù‚Ø±ÙŠØ¨Ø§Ù‹."
        },
        {
          type: "FOOTER",
          text: "Ø´ÙƒØ±Ø§Ù‹ Ù„Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ"
        }
      ]
    }
  },
  
  // Support Request Template (for internal use - to notify support team)
  support_request: {
    en: {
      name: "support_request_en",
      language: "en",
      components: [
        {
          type: "HEADER",
          format: "TEXT",
          text: "New Support Request"
        },
        {
          type: "BODY",
          text: "Client requires assistance:\n\nName: {{1}}\nID: {{2}}\nPhone: {{3}}\nProperty: {{4}}\n\nPlease contact the client as soon as possible."
        }
      ]
    },
    ar: {
      name: "support_request_ar",
      language: "ar",
      components: [
        {
          type: "HEADER",
          format: "TEXT",
          text: "Ø·Ù„Ø¨ Ø¯Ø¹Ù… Ø¬Ø¯ÙŠØ¯"
        },
        {
          type: "BODY",
          text: "Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ­ØªØ§Ø¬ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©:\n\nØ§Ù„Ø§Ø³Ù…: {{1}}\nØ§Ù„Ø±Ù‚Ù…: {{2}}\nØ§Ù„Ù‡Ø§ØªÙ: {{3}}\nØ§Ù„Ø¹Ù‚Ø§Ø±: {{4}}\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª Ù…Ù…ÙƒÙ†."
        }
      ]
    }
  }
};

/**
 * Route handler for WhatsApp webhook verification (GET)
 */
export async function GET(req) {
  try {
    console.log('Received webhook verification request');
    
    // Extract URL parameters for webhook verification
    const url = new URL(req.url);
    const mode = url.searchParams.get('hub.mode');
    const token = url.searchParams.get('hub.verify_token');
    const challenge = url.searchParams.get('hub.challenge');
    
    const verifyToken = process.env.WHATSAPP_VERIFY_TOKEN;
    
    if (mode === 'subscribe' && token === verifyToken) {
      console.log('Webhook verified successfully');
      return new NextResponse(challenge);
    } else {
      console.error('Verification failed. Invalid token.');
      return new NextResponse('Verification Failed', { status: 403 });
    }
  } catch (error) {
    console.error('Error handling webhook verification:', error);
    return new NextResponse('Internal Server Error', { status: 500 });
  }
}

/**
 * Route handler for WhatsApp webhook events (POST)
 */
export async function POST(req) {
  const prisma = getPrismaClient();
  
  try {
    console.log('ğŸ”„ ======= WEBHOOK EVENT RECEIVED =======');
    console.log('â° Timestamp:', new Date().toISOString());
    
    // Parse request body
    const body = await req.json();
    console.log('ğŸ“¦ Webhook payload:', JSON.stringify(body, null, 2));
    
    const { object, entry } = body;
    
    // Generate a unique ID for this webhook event
    const webhookId = generateWebhookId(body);
    
    // Check if this webhook event has already been processed
    if (processedWebhookIds.has(webhookId)) {
      console.log(`Webhook event ${webhookId} already processed, skipping`);
      return new NextResponse('ALREADY_PROCESSED', { status: 200 });
    }
    
    // Add this webhook ID to the processed set
    // In production, use Redis with TTL
    processedWebhookIds.add(webhookId);
    
    // Clean up old webhook IDs to prevent memory leaks
    // Only needed for in-memory solution, not for Redis
    if (processedWebhookIds.size > 1000) {
      const idsToDelete = Array.from(processedWebhookIds).slice(0, 500);
      idsToDelete.forEach(id => processedWebhookIds.delete(id));
    }
    
    // Validate it's a WhatsApp Business API webhook event
    if (object !== 'whatsapp_business_account') {
      console.error('Invalid webhook event received');
      return new NextResponse('Invalid webhook event', { status: 400 });
    }
    
    let hasProcessedMessage = false;
    
    // Process each entry in the webhook event
    for (const entryItem of entry) {
      for (const change of entryItem.changes) {
        if (change.field !== 'messages') continue;
        
        const value = change.value;
        if (!value.messages || value.messages.length === 0) continue;
        
        // Process each message
        for (const message of value.messages) {
          await processWhatsAppMessage(message, value.metadata, prisma);
          hasProcessedMessage = true;
        }
      }
    }
    
    // Return 200 OK to acknowledge receipt of the webhook event
    return new NextResponse(hasProcessedMessage ? 'MESSAGE_PROCESSED' : 'EVENT_RECEIVED', { status: 200 });
  } catch (error) {
    console.error('Error handling webhook event:', error);
    return new NextResponse('Internal Server Error', { status: 500 });
  } finally {
    // No need to explicitly disconnect in serverless functions
    // Next.js will handle this for us
  }
}

/**
 * Generate a unique ID for a webhook event to prevent duplicate processing
 */
function generateWebhookId(webhookBody) {
  try {
    // Extract identifying information from the webhook
    const entries = webhookBody.entry || [];
    const changes = entries.flatMap(entry => entry.changes || []);
    const messages = changes.flatMap(change => {
      if (change.field === 'messages' && change.value && change.value.messages) {
        return change.value.messages;
      }
      return [];
    });
    
    // Use message IDs as part of the webhook ID
    const messageIds = messages.map(msg => msg.id).join('-');
    const timestamp = Date.now().toString();
    
    return `${messageIds}-${timestamp}`;
  } catch (error) {
    console.error('Error generating webhook ID:', error);
    return `fallback-${Date.now()}`;
  }
}

/**
 * Send language selection options to the user
 * @param {string} phoneNumber - The recipient's phone number
 */
const sendLanguageOptions = async (phoneNumber) => {
  try {
    // Default to English for the language selection menu
    const interactiveContent = {
      type: "list",
      header: {
        type: "text",
        text: "Language Selection / Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©"
      },
      body: {
        text: "Please select your preferred language / ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ù„ØºØªÙƒ Ø§Ù„Ù…ÙØ¶Ù„Ø©"
      },
      footer: {
        text: "Your selection will be saved for future interactions / Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ù„Ù„ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©"
      },
      action: {
        button: "Select Language / Ø§Ø®ØªØ± Ø§Ù„Ù„ØºØ©",
        sections: [
          {
            title: "Available Languages / Ø§Ù„Ù„ØºØ§Øª Ø§Ù„Ù…ØªÙˆÙØ±Ø©",
            rows: [
              {
                id: "select_arabic",
                title: "Arabic / Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
                description: "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
              },
              {
                id: "select_english",
                title: "English / Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©",
                description: "Use English language"
              }
            ]
          }
        ]
      }
    };
    
    await sendInteractiveWhatsAppMessage(phoneNumber, interactiveContent);
    
    // Mark this phone number as being in a language selection session
    languageSelectionSessions.set(phoneNumber, {
      active: true,
      timestamp: Date.now()
    });
    
    // Clean up old language selection sessions (older than 1 hour)
    const currentTime = Date.now();
    for (const [phone, session] of languageSelectionSessions.entries()) {
      if (currentTime - session.timestamp > 60 * 60 * 1000) {
        languageSelectionSessions.delete(phone);
      }
    }
  } catch (error) {
    console.error('Error sending language options:', error);
    // Fallback to bilingual message
    await sendWhatsAppMessage(
      phoneNumber, 
      "Welcome! We're preparing our service for you. / Ù…Ø±Ø­Ø¨Ù‹Ø§! Ù†Ø­Ù† Ù†Ù‚ÙˆÙ… Ø¨Ø¥Ø¹Ø¯Ø§Ø¯ Ø®Ø¯Ù…ØªÙ†Ø§ Ù„Ùƒ."
    );
  }
};


/**
 * Send maintenance options menu to the user
 * @param {string} phoneNumber - The recipient's phone number
 * @param {string} language - The client's language preference
 */
const sendMaintenanceOptions = async (phoneNumber, language) => {
  try {
    const localizedMessages = getLocalizedMessages(language, messages);
    
    const interactiveContent = {
      type: "list",
      header: {
        type: "text",
        text: localizedMessages.maintenanceOptionsHeader
      },
      body: {
        text: localizedMessages.maintenanceOptionsBody
      },
      footer: {
        text: localizedMessages.maintenanceOptionsFooter
      },
      action: {
        button: localizedMessages.maintenanceOptionsButton,
        sections: [
          {
            title: localizedMessages.maintenanceTitle,
            rows: [
              {
                id: "submit_maintenance",
                title: localizedMessages.submitMaintenanceTitle,
                description: localizedMessages.submitMaintenanceDesc
              },
              {
                id: "submit_complaint",
                title: localizedMessages.submitComplaintTitle,
                description: localizedMessages.submitComplaintDesc
              },
              {
                id: "contact_support",
                title: localizedMessages.contactSupportTitle,
                description: localizedMessages.contactSupportDesc
              },
              {
                id: "change_language",
                title: localizedMessages.changeLanguageTitle || "Change Language / ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ©",
                description: localizedMessages.changeLanguageDesc || "Update your language preference / ØªØ­Ø¯ÙŠØ« ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù„ØºØ©"
              }
            ]
          }
        ]
      }
    };
    
    await sendInteractiveWhatsAppMessage(phoneNumber, interactiveContent);
  } catch (error) {
    console.error('Error sending maintenance options:', error);
    // Fallback to regular message
    const localizedMessages = getLocalizedMessages(language, messages);
    await sendWhatsAppMessage(
      phoneNumber, 
      localizedMessages.welcomeMessage
    );
  }
};

/**
 * Handle interactive message responses
 * @param {Object} interactive - The interactive message response
 * @param {string} phoneNumber - The sender's phone number
 * @param {string} language - The client's language preference
 * @param {PrismaClient} prisma - Prisma client instance
 */
const handleInteractiveResponse = async (interactive, phoneNumber, language, prisma) => {
  try {
    const localizedMessages = getLocalizedMessages(language, messages);
    
    // Handle list response selection
    if (interactive.list_reply) {
      const selectedOption = interactive.list_reply.id;
      
      // Special case: language change requested
      if (selectedOption === 'change_language') {
        await sendLanguageOptions(phoneNumber);
        return;
      }
      
      // Verify this is a registered client
      const client = await findClientByPhone(phoneNumber, prisma);
      if (!client) {
        await sendWhatsAppMessage(
          phoneNumber, 
          localizedMessages.notFoundInSystemMessage
        );
        return;
      }
      
      // Store the client's current action for context tracking
      if (selectedOption === 'submit_maintenance') {
        await prisma.client.update({
          where: { id: client.id },
          data: { 
            language: language,
            lastAction: 'MAINTENANCE_REQUEST'
          }
        });
        
        await sendWhatsAppMessage(
          phoneNumber, 
          localizedMessages.describeMaintenanceMessage
        );
      } else if (selectedOption === 'submit_complaint') {
        await prisma.client.update({
          where: { id: client.id },
          data: { 
            language: language,
            lastAction: 'COMPLAINT_SUBMISSION'
          }
        });
        
        await sendWhatsAppMessage(
          phoneNumber, 
          localizedMessages.describeComplaintMessage
        );
      } else if (selectedOption === 'contact_support') {
        await handleContactSupport(phoneNumber, client, language, prisma);
      }
    }
    
    // Handle button response
    if (interactive.button_reply) {
      const buttonId = interactive.button_reply.id;
      const [action, confirmationId] = buttonId.split('|');
      
      // Retrieve the stored description from our temporary cache
      if (!global.pendingConfirmations) global.pendingConfirmations = new Map();
      const pendingConfirmation = global.pendingConfirmations.get(confirmationId);
      
      if (!pendingConfirmation) {
        // Confirmation expired or invalid
        await sendWhatsAppMessage(
          phoneNumber,
          localizedMessages.errorMessage + " " + 
          (language === "ARABIC" ? 
            "ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨Ùƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." : 
            "Please submit your request again.")
        );
        return;
      }
      
      const { description, isComplaint } = pendingConfirmation;
      
      // Clean up the used confirmation
      global.pendingConfirmations.delete(confirmationId);
      
      if (action === 'confirm_maintenance') {
        // Handle maintenance request confirmation
        await createMaintenanceRequest(phoneNumber, description, language, prisma);
      } else if (action === 'confirm_complaint') {
        // Handle complaint confirmation
        await createComplaint(phoneNumber, description, language, prisma);
      }
    }
  } catch (error) {
    console.error('Error handling interactive response:', error);
    // Send error message
    try {
      const localizedMessages = getLocalizedMessages(language, messages);
      await sendWhatsAppMessage(
        phoneNumber,
        localizedMessages.errorMessage
      );
    } catch (sendError) {
      console.error('Failed to send error message:', sendError);
    }
  }
};

/**
 * Handle contact support request
 * @param {string} phoneNumber - The client's phone number
 * @param {Object} client - The client object
 * @param {string} language - The client's language preference
 * @param {PrismaClient} prisma - Prisma client instance
 */
const handleContactSupport = async (phoneNumber, client, language, prisma) => {
  try {
    const localizedMessages = getLocalizedMessages(language, messages);
    const supportPhoneNumber = process.env.SUPPORT_PHONE_NUMBER;
    
    if (!supportPhoneNumber) {
      console.error('Support phone number not configured');
      await sendWhatsAppMessage(
        phoneNumber,
        localizedMessages.errorMessage
      );
      return;
    }
    
    // Notify the client that support will contact them
    await sendWhatsAppMessage(
      phoneNumber,
      localizedMessages.supportWillContactMessage
    );
    
    // Send client details to support using template
    const { languageCode, templateName } = getClientLanguageSettings(language, "support_request");
    
    // Format client information
    const clientInfo = {
      clientName: client.name,
      clientId: client.id,
      clientPhone: phoneNumber,
      propertyInfo: '', // Can be populated if needed
      timestamp: new Date().toISOString()
    };
    
    // Send template message to support team
    await sendWhatsAppMessage(
      supportPhoneNumber,
      clientInfo,
      true, // Use template
      'support_request', // Base template name
      'en' // Default to English for support staff
    );
    
    // Log the support request
    console.log(`Support request sent for client ${client.id} to ${supportPhoneNumber}`);
    
    // Optionally: Store the support request in the database
    await prisma.supportRequest.create({
      data: {
        clientId: client.id,
        status: 'PENDING',
        createdAt: new Date()
      }
    }).catch(err => {
      // Don't let this error affect the user flow
      console.error('Error creating support request record:', err);
    });
    
  } catch (error) {
    console.error('Error handling contact support:', error);
    const localizedMessages = getLocalizedMessages(language, messages);
    await sendWhatsAppMessage(
      phoneNumber,
      localizedMessages.errorMessage
    );
  }
};


/**
 * Send maintenance or complaint confirmation message
 * @param {string} phoneNumber - The recipient's phone number
 * @param {string} description - The request description
 * @param {string} language - The client's language preference
 */
const sendConfirmation = async (phoneNumber, description, language, isComplaint, prisma) => {
  try {
    const localizedMessages = getLocalizedMessages(language, messages);
    
    // Generate a unique hash or timestamp for this confirmation
    const confirmationId = `${Date.now()}_${phoneNumber.slice(-4)}`;
    
    // Store description in a temporary cache
    if (!global.pendingConfirmations) global.pendingConfirmations = new Map();
    global.pendingConfirmations.set(confirmationId, {
      description,
      isComplaint,
      timestamp: Date.now()
    });
    
    // Clean up old entries (older than 1 hour)
    for (const [key, value] of global.pendingConfirmations.entries()) {
      if (Date.now() - value.timestamp > 60 * 60 * 1000) {
        global.pendingConfirmations.delete(key);
      }
    }
    
    // Select the appropriate confirmation title and button based on type
    const confirmationTitle = isComplaint ? 
      localizedMessages.complaintConfirmationTitle : 
      localizedMessages.maintenanceConfirmationTitle;
    
    const buttonTitle = isComplaint ?
      localizedMessages.confirmComplaintButton :
      localizedMessages.confirmButton;
    
    // Create appropriate button ID
    const buttonIdText = isComplaint ? 
      `confirm_complaint|${confirmationId}` :
      `confirm_maintenance|${confirmationId}`;
    
    // Truncate description for display if too long
    const displayDescription = description.length > 200 ? 
      description.substring(0, 197) + '...' : 
      description;
    
    // Create the interactive content for the confirmation
    const interactiveContent = {
      type: "button",
      body: {
        text: `${confirmationTitle}\n\n"${displayDescription}"\n\n${localizedMessages.confirmationQuestion}`
      },
      action: {
        buttons: [
          {
            type: "reply",
            reply: {
              id: buttonIdText,
              title: buttonTitle
            }
          }
        ]
      }
    };
    
    // Send the interactive message
    await sendInteractiveWhatsAppMessage(phoneNumber, interactiveContent);
    
    // Optional: Log the confirmation type for debugging
    console.log(`Sent ${isComplaint ? 'complaint' : 'maintenance'} confirmation to ${phoneNumber}`);
    
  } catch (error) {
    console.error('Error sending confirmation:', error);
    // Fallback to regular message
    const localizedMessages = getLocalizedMessages(language, messages);
    await sendWhatsAppMessage(
      phoneNumber, 
      localizedMessages.errorMessage
    );
  }
};

// You can keep the original sendMaintenanceConfirmation as a wrapper for backward compatibility
const sendMaintenanceConfirmation = async (phoneNumber, description, language, prisma) => {
  // By default, assume it's a maintenance request unless specified otherwise
  const client = await findClientByPhone(phoneNumber, prisma);
  const isComplaint = client && client.lastAction === 'COMPLAINT_SUBMISSION';
  
  await sendConfirmation(phoneNumber, description, language, isComplaint, prisma);
};

/**
 * Find a client by phone number
 * @param {string} phoneNumber - The client's phone number
 * @param {PrismaClient} prisma - Prisma client instance
 * @returns {Promise<Object|null>} - The client object or null if not found
 */
const findClientByPhone = async (phoneNumber, prisma) => {
  try {
    // Clean the phone number to match database format
    const cleanedPhone = phoneNumber.replace(/\D/g, '');
    
    // Search for a client with this phone number
    const client = await prisma.client.findFirst({
      where: {
        phone: {
          contains: cleanedPhone.substring(cleanedPhone.length - 9)
        }
      }
    });
    
    return client;
  } catch (error) {
    console.error('Error finding client by phone:', error);
    return null;
  }
};

/**
 * Create a new maintenance request and notify technician
 * @param {string} phoneNumber - The client's phone number
 * @param {string} description - The maintenance request description
 * @param {string} language - The client's language preference
 * @param {PrismaClient} prisma - Prisma client instance
 */
const createMaintenanceRequest = async (phoneNumber, description, language, prisma) => {
  try {
    const localizedMessages = getLocalizedMessages(language, messages);
    
    // First find the client
    const client = await findClientByPhone(phoneNumber, prisma);
    
    if (!client) {
      await sendWhatsAppMessage(
        phoneNumber,
        localizedMessages.notFoundInSystemMessage
      );
      return;
    }
    
    // Update client's language preference if it differs from current preference
    if (client.language !== language) {
      await prisma.client.update({
        where: { id: client.id },
        data: { language }
      });
      console.log(`Updated language preference for client ${client.id} to ${language}`);
    }
    
    // Check if the client has submitted a request in the last 24 hours
    const recentRequest = await prisma.maintenanceRequest.findFirst({
      where: {
        clientId: client.id,
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
        }
      }
    });
    
    if (recentRequest) {
      await sendWhatsAppMessage(
        phoneNumber,
        localizedMessages.recentRequestMessage
      );
      return;
    }
    
    // Find client's property and unit if available
    const clientProperties = await prisma.property.findMany({
      where: {
        clientId: client.id
      }
    });
    
    const clientUnits = await prisma.unit.findMany({
      where: {
        clientId: client.id
      }
    });
    
    // Create the maintenance request
    const maintenanceRequest = await prisma.maintenanceRequest.create({
      data: {
        clientId: client.id,
        propertyId: clientProperties.length > 0 ? clientProperties[0].id : null,
        unitId: clientUnits.length > 0 ? clientUnits[0].id : null,
        description: description,
        status: 'PENDING',
        isExpired: false,
        lastRequestTime: new Date()
      }
    });
    
    console.log(`Created maintenance request: ${maintenanceRequest.id}`);
    
    // Reset the client's lastAction
    await prisma.client.update({
      where: { id: client.id },
      data: { lastAction: null }
    });
    
    // Send confirmation to client based on language preference
    const { languageCode, templateName, isArabic } = getClientLanguageSettings(language, "maintenance_confirmation");
    const isWithin24HourWindow = true; // This would be determined based on WhatsApp session state
    
    if (isWithin24HourWindow) {
      // Send regular message
      const successMessage = localizedMessages.requestSuccessMessage
        .replace("{requestId}", maintenanceRequest.id)
        .replace("{description}", description);
      
      await sendWhatsAppMessage(
        phoneNumber,
        successMessage
      );
    } else {
      // Send template message for outside 24-hour window
      await sendWhatsAppMessage(
        phoneNumber,
        {
          requestId: `#${maintenanceRequest.id}`,
          description: description.substring(0, 60) // Limit length for template
        },
        true, // Use template
        templateName, // Template name with language suffix
        languageCode // Language code for template
      );
      
      // Mark the request as using a template (expired 24-hour window)
      await prisma.maintenanceRequest.update({
        where: { id: maintenanceRequest.id },
        data: { isExpired: true }
      });
    }
    
    // Notify technician about the new maintenance request
    await notifyTechnician(maintenanceRequest.id, prisma);
    
    // Add a record to track this interaction to prevent duplicate processing
    console.log(`Maintenance request created and processed: ${maintenanceRequest.id}`);
    
  } catch (error) {
    console.error('Error creating maintenance request:', error);
    const localizedMessages = getLocalizedMessages(language, messages);
    await sendWhatsAppMessage(
      phoneNumber,
      localizedMessages.errorMessage
    );
  }
};

/**
 * Create a new complaint and notify management
 * @param {string} phoneNumber - The client's phone number
 * @param {string} description - The complaint description
 * @param {string} language - The client's language preference
 * @param {PrismaClient} prisma - Prisma client instance
 */
const createComplaint = async (phoneNumber, description, language, prisma) => {
  try {
    console.log('ğŸ¯ ======= CREATING COMPLAINT =======');
    console.log(`ğŸ“± Phone: ${phoneNumber}`);
    console.log(`ğŸ“ Description: ${description}`);
    console.log(`ğŸŒ Language: ${language}`);
    console.log(`â° Timestamp: ${new Date().toISOString()}`);
    
    const localizedMessages = getLocalizedMessages(language, messages);
    
    // First find the client
    const client = await findClientByPhone(phoneNumber, prisma);
    
    if (!client) {
      console.log(`Client not found for phone: ${phoneNumber}`);
      await sendWhatsAppMessage(
        phoneNumber,
        localizedMessages.notFoundInSystemMessage
      );
      return;
    }
    
    console.log(`Found client: ${client.id}, ${client.name}`);
    
    // Update client's language preference if it differs from current preference
    if (client.language !== language) {
      await prisma.client.update({
        where: { id: client.id },
        data: { language }
      });
      console.log(`Updated language preference for client ${client.id} to ${language}`);
    }
    
    // Check if the client has submitted a complaint in the last 24 hours
    const recentComplaint = await prisma.complaint.findFirst({
      where: {
        clientId: client.id,
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
        }
      }
    });
    
    if (recentComplaint) {
      await sendWhatsAppMessage(
        phoneNumber,
        localizedMessages.recentComplaintMessage
      );
      return;
    }
    
    // Find client's property and unit if available
    const clientProperties = await prisma.property.findMany({
      where: {
        clientId: client.id
      }
    });
    
    const clientUnits = await prisma.unit.findMany({
      where: {
        clientId: client.id
      }
    });
    
    // Create the complaint with all required fields
    const complaint = await prisma.complaint.create({
      data: {
        clientId: client.id,
        propertyId: clientProperties.length > 0 ? clientProperties[0].id : null,
        unitId: clientUnits.length > 0 ? clientUnits[0].id : null,
        title: description.length > 50 ? description.substring(0, 50) + "..." : description, // Required field
        description: description,
        category: 'OTHER', // Default category, required field
        status: 'PENDING',
        createdAt: new Date(), // Ensure creation date is set
        updatedAt: new Date()  // Ensure update date is set
      }
    });
    
    console.log(`Created complaint: ${complaint.id}`);
    
    // Reset the client's lastAction
    await prisma.client.update({
      where: { id: client.id },
      data: { lastAction: null }
    });
    
    // Send confirmation to client based on language preference
    const { languageCode, templateName, isArabic } = getClientLanguageSettings(language, "complaint_confirmation");
    
    // Check if we're within the 24-hour messaging window
    const isWithin24HourWindow = true; // This would be determined based on WhatsApp session state
    
    if (isWithin24HourWindow) {
      // Send regular message
      const successMessage = localizedMessages.complaintSuccessMessage
        .replace("{complaintId}", complaint.id)
        .replace("{description}", description);
      
      await sendWhatsAppMessage(
        phoneNumber,
        successMessage
      );
    } else {
      // Send template message for outside 24-hour window
      await sendWhatsAppMessage(
        phoneNumber,
        {
          complaintId: `#${complaint.id}`,
          description: description.substring(0, 60) // Limit length for template
        },
        true, // Use template
        templateName, // Template name with language suffix
        languageCode // Language code for template
      );
      
      // Mark the complaint as using a template (expired 24-hour window)
      await prisma.complaint.update({
        where: { id: complaint.id },
        data: { isExpired: true }
      });
    }
    
    // Notify management about the new complaint
    await notifyManagement(complaint.id, prisma);
    
    console.log(`Complaint created and processed: ${complaint.id}`);
    // Don't execute any more code after this that could throw errors
    
  } catch (error) {
    console.error('âŒ ======= COMPLAINT CREATION ERROR =======');
    console.error('â° Timestamp:', new Date().toISOString());
    console.error('ğŸ“± Phone:', phoneNumber);
    console.error('ğŸ’¥ Error creating complaint:', error);
    console.error('ğŸ” Error details:', {
      name: error.name,
      message: error.message,
      code: error.code,
      stack: error.stack
    });
    
    const localizedMessages = getLocalizedMessages(language, messages);
    
    // Send more specific error message to user
    let errorMessage = localizedMessages.errorMessage;
    
    if (error.code === 'P2002') {
      // Unique constraint violation
      errorMessage = language === 'ARABIC' 
        ? 'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªÙ‚Ø¯ÙŠÙ… Ø´ÙƒÙˆÙ‰ Ù…ÙƒØ±Ø±Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.'
        : 'Sorry, duplicate complaint cannot be submitted. Please try again later.';
    } else if (error.code === 'P2003') {
      // Foreign key constraint violation
      errorMessage = language === 'ARABIC'
        ? 'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù…ÙƒØªØ¨.'
        : 'Sorry, we could not find your information in our system. Please contact our office.';
    } else if (error.message.includes('required')) {
      // Missing required field
      errorMessage = language === 'ARABIC'
        ? 'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø·Ù„ÙˆØ¨Ø© Ù…ÙÙ‚ÙˆØ¯Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ.'
        : 'Sorry, some required information is missing. Please try again or contact technical support.';
    }
    
    await sendWhatsAppMessage(
      phoneNumber,
      errorMessage
    );
  }
};

/**
 * Notify management about a new complaint
 * @param {number} complaintId - The ID of the complaint
 * @param {PrismaClient} prisma - Prisma client instance
 */
const notifyManagement = async (complaintId, prisma) => {
  try {
    const complaint = await prisma.complaint.findUnique({
      where: { id: complaintId },
      include: {
        client: true,
        property: true,
        unit: true
      }
    });
    
    if (!complaint) {
      console.error(`Complaint with ID ${complaintId} not found`);
      return;
    }
    
    // Get management phone number from environment variables
    const managementPhone = process.env.MANAGEMENT_PHONE_NUMBER;
    
    if (!managementPhone) {
      console.error('Management phone number not configured');
      return;
    }
    
    // Format property and unit information if available
    const propertyInfo = complaint.property ? `\nProperty: ${complaint.property.name}` : '';
    const unitInfo = complaint.unit ? `\nUnit: ${complaint.unit.number}` : '';
    
    // Send notification to management
    await sendWhatsAppMessage(
      managementPhone,
      `New Complaint #${complaintId}\n` +
      `From: ${complaint.client.name}\n` +
      `Phone: ${complaint.client.phone}` +
      propertyInfo +
      unitInfo +
      `\n\nDescription: ${complaint.description}\n\n` +
      `Please review and take appropriate action.`
    );
    
    console.log(`Management notified about complaint ${complaintId}`);
    
  } catch (error) {
    console.error('Error notifying management about complaint:', error);
  }
};

/**
 * Modified processWhatsAppMessage function to handle language selection at the beginning
 * @param {Object} message - The message object from the webhook
 * @param {Object} metadata - Message metadata
 * @param {PrismaClient} prisma - Prisma client instance
 */
const processWhatsAppMessage = async (message, metadata, prisma) => {
  try {
    // Extract sender information
    const senderPhone = message.from;
    const recipientPhoneId = metadata.phone_number_id;
    
    console.log(`Processing message from ${senderPhone}`);
    
    // Check if the sender is a technician
    const technicianPhone = process.env.TECHNICIAN_PHONE;
    if (senderPhone === technicianPhone) {
      await handleTechnicianResponse(message, senderPhone, prisma);
      return;
    }
    
    // First message or initial greetings should always trigger language selection
    const isFirstInteraction = !message.interactive; // Not responding to an interactive message
    
    // Check for common greeting messages in any language
    let isGreeting = false;
    if (message.text) {
      const messageText = message.text.body.trim().toLowerCase();
      const greetings = ['hi', 'hello', 'start', 'help', 'Ù…Ø±Ø­Ø¨Ø§', 'Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…', 'Ø§Ø¨Ø¯Ø£', 'Ø¨Ø¯Ø§ÙŠØ©'];
      isGreeting = greetings.some(greeting => messageText === greeting);
    }
    
    // Always send language options for first interaction or greeting
    if (isGreeting || isFirstInteraction && !message.text) {
      await sendInitialLanguageOptions(senderPhone);
      return;
    }
    
    // Process interactive messages (button responses)
    if (message.interactive) {
      // Check if this is a language selection response
      if (message.interactive.list_reply) {
        const selectedOption = message.interactive.list_reply.id;
        
        if (selectedOption === 'select_arabic' || selectedOption === 'select_english') {
          await handleLanguageSelection(selectedOption, senderPhone, prisma);
          return;
        }
      }
      
      // Find client to get language preference
      const client = await findClientByPhone(senderPhone, prisma);
      // Default to English if client not found (based on logs showing English selection)
      const language = client ? client.language || "ENGLISH" : "ENGLISH";
      
      await handleInteractiveResponse(message.interactive, senderPhone, language, prisma);
      return;
    }
    
    // For non-interactive text messages
    if (message.text) {
      const messageText = message.text.body.trim();
      
      // Check if the client exists and get their language preference
      const client = await findClientByPhone(senderPhone, prisma);
      
      // If this is likely a first interaction with just text, send language options
      if (!client && messageText.length < 10) {
        await sendInitialLanguageOptions(senderPhone);
        return;
      }
      
      const language = client ? client.language || "ENGLISH" : "ENGLISH";
      const localizedMessages = getLocalizedMessages(language, messages);
      
      // Check the client's last action to determine context
      const lastAction = client ? client.lastAction : null;
      
      if (lastAction === 'COMPLAINT_SUBMISSION') {
        // This is a response to our request for complaint details
        // Pass isComplaint=true to the confirmation function
        await sendConfirmation(senderPhone, messageText, language, true, prisma);
        return;
      } else if (lastAction === 'MAINTENANCE_REQUEST') {
        // This is a response to our request for maintenance details
        // Pass isComplaint=false to the confirmation function
        await sendConfirmation(senderPhone, messageText, language, false, prisma);
        return;
      } else if (messageText.length > 5) {
        // For messages without context, try to determine if it's a complaint
        const isComplaint = messageText.toLowerCase().includes('complaint') || 
                        messageText.toLowerCase().includes('Ø´ÙƒÙˆÙ‰') ||
                        messageText.toLowerCase().includes('Ø§Ø´ØªÙƒÙŠ') ||
                        messageText.toLowerCase().includes('Ø£Ø´ÙƒÙˆ');
        
        await sendConfirmation(senderPhone, messageText, language, isComplaint, prisma);
        return;
      }
      
      // Default: send maintenance options
      await sendMaintenanceOptions(senderPhone, language);
    }
  } catch (error) {
    console.error('Error processing WhatsApp message:', error);
    
    // Attempt to send a generic error message if we can determine the sender
    try {
      if (message && message.from) {
        // Try to determine client language preference
        const client = await findClientByPhone(message.from, prisma).catch(() => null);
        const language = client ? client.language || "ENGLISH" : "ENGLISH";
        const localizedMessages = getLocalizedMessages(language, messages);
        
        await sendWhatsAppMessage(
          message.from,
          localizedMessages.errorMessage
        );
      }
    } catch (sendError) {
      console.error('Failed to send error message:', sendError);
    }
  }
};

/**
 * Send initial language selection options to the user at the beginning of the conversation
 * @param {string} phoneNumber - The recipient's phone number
 */
const sendInitialLanguageOptions = async (phoneNumber) => {
  try {
    // Bilingual language selection menu
    const interactiveContent = {
      type: "list",
      header: {
        type: "text",
        text: "Welcome / Ù…Ø±Ø­Ø¨Ø§Ù‹"
      },
      body: {
        text: "Please select your preferred language to continue.\nÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù„ØºØªÙƒ Ø§Ù„Ù…ÙØ¶Ù„Ø© Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©."
      },
      footer: {
        text: "Your language selection will be saved for future interactions"
      },
      action: {
        button: "Select Language / Ø§Ø®ØªØ± Ø§Ù„Ù„ØºØ©",
        sections: [
          {
            title: "Available Languages / Ø§Ù„Ù„ØºØ§Øª Ø§Ù„Ù…ØªÙˆÙØ±Ø©",
            rows: [
              {
                id: "select_arabic",
                title: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© / Arabic",
                description: "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§"
              },
              {
                id: "select_english",
                title: "English / Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©",
                description: "Use English language for communication"
              }
            ]
          }
        ]
      }
    };
    
    await sendInteractiveWhatsAppMessage(phoneNumber, interactiveContent);
    
    // Mark this phone number as being in a language selection session
    languageSelectionSessions.set(phoneNumber, {
      active: true,
      timestamp: Date.now()
    });
    
    // Clean up old language selection sessions (older than 1 hour)
    const currentTime = Date.now();
    for (const [phone, session] of languageSelectionSessions.entries()) {
      if (currentTime - session.timestamp > 60 * 60 * 1000) {
        languageSelectionSessions.delete(phone);
      }
    }
  } catch (error) {
    console.error('Error sending initial language options:', error);
    // Fallback to bilingual message
    await sendWhatsAppMessage(
      phoneNumber, 
      "Welcome! Please reply with 'English' or 'Arabic' to continue. / Ù…Ø±Ø­Ø¨Ù‹Ø§! ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¯ Ø¨Ù€ 'English' Ø£Ùˆ 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©."
    );
  }
};

/**
 * Modified handleLanguageSelection function to handle initial language selection
 * @param {string} selectedOption - The selected language option
 * @param {string} phoneNumber - The sender's phone number
 * @param {PrismaClient} prisma - Prisma client instance
 */
const handleLanguageSelection = async (selectedOption, phoneNumber, prisma) => {
  try {
    // Determine selected language
    let language = "ARABIC"; // Default
    if (selectedOption === 'select_english') {
      language = "ENGLISH";
    }
    
    // Check if the user is registered in the system
    let client = await findClientByPhone(phoneNumber, prisma);
    
    if (client) {
      // Update the client's language preference
      await prisma.client.update({
        where: { id: client.id },
        data: { language }
      });
      console.log(`Updated language preference for client ${client.id} to ${language}`);
    } else {
      // Store language preference in temporary session
      console.log(`Client with phone ${phoneNumber} not found in system, storing preference temporarily`);
      // We could create a temporary user record here if needed
    }
    
    // Mark language selection as complete
    if (languageSelectionSessions.has(phoneNumber)) {
      languageSelectionSessions.delete(phoneNumber);
    }
    
    // Send confirmation in selected language
    const localizedMessages = getLocalizedMessages(language, messages);
    await sendWhatsAppMessage(
      phoneNumber,
      localizedMessages.languageSelectedMessage || 
      (language === "ARABIC" ? 
        "ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ" : 
        "English language selected. How can we assist you today?")
    );
    
    // Send maintenance options in selected language
    await sendMaintenanceOptions(phoneNumber, language);
    
  } catch (error) {
    console.error('Error handling language selection:', error);
    // Send generic error message in both languages
    await sendWhatsAppMessage(
      phoneNumber,
      "An error occurred. Please try again. / Ø­Ø¯Ø« Ø®Ø·Ø£. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰."
    );
  }
};

/**
 * Update the message templates for better bilingual support
 */
const updateMessagesList = () => {
  // Extend the existing MessagesList to ensure proper bilingual support
  return {
    ...MessagesList,
    // Override or add new message templates
    maintenanceOptionsHeader: {
      en: "Maintenance Services",
      ar: "Ø®Ø¯Ù…Ø§Øª Ø§Ù„ØµÙŠØ§Ù†Ø©"
    },
    maintenanceOptionsBody: {
      en: "How can we assist you today? Please select an option below.",
      ar: "ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø®ÙŠØ§Ø± Ù…Ù† Ø£Ø¯Ù†Ø§Ù‡."
    },
    maintenanceOptionsFooter: {
      en: "Your satisfaction is our priority",
      ar: "Ø±Ø¶Ø§Ùƒ Ù‡Ùˆ Ø£ÙˆÙ„ÙˆÙŠØªÙ†Ø§"
    },
    maintenanceOptionsButton: {
      en: "Select Option",
      ar: "Ø§Ø®ØªØ± Ø®ÙŠØ§Ø±Ù‹Ø§"
    },
    languageSelectedMessage: {
      en: "English language selected. How can we assist you today?",
      ar: "ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ"
    },
    welcomeMessage: {
      en: "Welcome to our property maintenance system. How can we help you today?",
      ar: "Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… ØµÙŠØ§Ù†Ø© Ø§Ù„Ø¹Ù‚Ø§Ø±Ø§Øª Ù„Ø¯ÙŠÙ†Ø§. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ"
    },
    errorMessage: {
      en: "We're experiencing technical difficulties. Please try again later.",
      ar: "Ù†ÙˆØ§Ø¬Ù‡ ØµØ¹ÙˆØ¨Ø§Øª ÙÙ†ÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§."
    }
  };
};

/**
 * Schedule regular checks for pending maintenance requests
 * to follow up with clients and technicians
 */
const scheduleMaintenanceFollowups = () => {
  // This would be implemented with a cron job or scheduled task
  // For serverless environments, you might use a separate endpoint triggered by a scheduler
  console.log('Scheduled maintenance followups initialized');
  
  // The actual implementation would check for:
  // 1. Pending requests older than X hours
  // 2. In-progress requests older than Y days
  // 3. Send appropriate reminders to technicians and clients
};

/**
 * Initialize the webhook handler with updated message templates
 */
const initializeWebhookHandler = () => {
  // Update message templates
  const updatedMessages = updateMessagesList();
  
  // Override the global MessagesList if needed
  // MessagesList = updatedMessages;
  
  // Schedule maintenance followups
  scheduleMaintenanceFollowups();
  
  console.log('WhatsApp webhook handler initialized with updated language support');
};

// Call initialization when the module loads
initializeWebhookHandler();